

from PIL import Image, ImageOps
import numpy as np
import os
import time
import sys

class GBTD:
    def __init__(self, image_input, filepath=None, filename=None):

        if isinstance(image_input, Image.Image):
            self.img = image_input
            self.extension = ".jpg"
        else:
            self.img = Image.open(image_input)
            self.extension = image_input.split("/")[-1].split(".")[-1]
            
        self.filepath = filepath
        self.filename = filename
    
    def show_img(self):
        """Display the image."""
        self.img.show()

    def resize_image(self, height=None, width=None, show=False):
        """
        Resizes an image from a given filepath to specified dimensions.

        Args:
        input_filepath (str): Path to the input image file.
        height (int, optional): Desired height of the image. Defaults to 8.
        width (int, optional): Desired width of the image. Defaults to 8.

        Returns:
        PIL.Image.Image: The resized image.
        """

        if not height and not width:
            return

        # Resize the image to the specified dimensions
        self.img = self.img.resize((width, height), Image.LANCZOS)

    def pad_img(self):
        """Pad the image symmetrically to ensure the width is a multiple of 8."""
        width, height = self.img.size
        new_width = ((width + 7) // 8) * 8
        padding = (new_width - width) // 2
        self.img = ImageOps.expand(self.img, border=(padding, 0), fill=0)
        if (new_width - width) % 2 != 0:
            self.img = ImageOps.expand(self.img, border=(0, 0, 1, 0), fill=(0, 0, 0))

    def convert_to_grayscale(self):
        """Convert the image to grayscale."""
        self.img = self.img.convert('L')

    def quantize_img(self):
        """Quantize the image to 0-3 levels."""
        scale = 256 // 4
        # The 3- below also inverts the colors
        # Consider making a separate invert function
        self.img = self.img.point(lambda x: 3-(x // scale)) 

    def save_img(self, directory=None, filename=None):
        """Save the image to the specified filepath."""
        if not filepath:
            directory = self.filepath
            filename = self.filename
        filepath = os.path.join(directory, filename + self.extension)
        self.img.save(filepath)

    def split_img(self):
        """Split the image into Nx8 sets of pixels."""
        width, height = self.img.size
        assert width % 8 == 0, "Width must be a multiple of 8"
        return [self.img.crop((x, 0, x + 8, height)) for x in range(0, width, 8)]

    def get_pixel_values(self):
        """Return a 1-dimensional list of each pixel value in the image."""
        return list(self.img.getdata())

    def convert_to_gbtd(self, pixel_arrays):
        """Convert arrays of pixels into GBTD format."""
        final_output = []

        # Adjust input to ensure it is a list of lists
        if not isinstance(pixel_arrays[0], list):
            pixel_arrays = [pixel_arrays]

        for pixel_array in pixel_arrays:
            msb, lsb = "", ""
            for i, pixel in enumerate(pixel_array):
                msb += str(pixel // 2)
                lsb += str(pixel % 2)
                # Process each 8 pixels as one byte
                if (i + 1) % 8 == 0:
                    final_output.extend([int(msb, 2), int(lsb, 2)])
                    msb, lsb = "", ""

        return final_output

    def write_c_h_files(self, gbtd_array, directory=None, filename=None):
       
        if not directory:
            directory = "./"
        if not filename:
            filename = "output"

        c_filename = os.path.join(directory, filename + ".c")
        h_filename = os.path.join(directory, filename + ".h")

        # Format hex values with line breaks after every 8 values
        hex_lines = []
        for i in range(0, len(gbtd_array), 8):
            line = ", ".join(f"0x{value:02X}" for value in gbtd_array[i:i+8])
            hex_lines.append(line)
        hex_values = ",\n  ".join(hex_lines)

        c_content = f"""/*
 {filename.upper()}.C

 Tile Source File.

 Info:
  Form                 : All tiles as one unit.
  Format               : Gameboy 4 color.
  Compression          : None.
  Counter              : None.
  Tile size            : 8 x 8
  Tiles                : 0 to 0

  Palette colors       : None.
  SGB Palette          : None.
  CGB Palette          : None.

  Convert to metatiles : No.

 This file was generated by GBTD python class

*/

/* Start of tile array. */
unsigned char {filename}[] =
{{
  {hex_values}
}};

/* End of {filename.upper()}.C */
"""

        h_content = f"""/*
 {filename.upper()}.H

 Include File.

 Info:
  Form                 : All tiles as one unit.
  Format               : Gameboy 4 color.
  Compression          : None.
  Counter              : None.
  Tile size            : N x N
  Tiles                : N to N

  Palette colors       : None.
  SGB Palette          : None.
  CGB Palette          : None.

  Convert to metatiles : No.

 This file was generated by GBTD python class

*/

/* Bank of tiles. */
#define {filename}Bank 0
/* Start of tile array. */
extern unsigned char {filename}[];

/* End of {filename.upper()}.H */
"""

        with open(c_filename, "w") as c_file:
            c_file.write(c_content)

        with open(h_filename, "w") as h_file:
            h_file.write(h_content)

        return c_filename, h_filename

    @staticmethod
    def generate_image(height=8, width=8, color=None, filepath=None):
        # Define a dictionary to map color names to RGB values
        color_map = {
            'black': (0, 0, 0),
            'white': (255, 255, 255),
            'dark grey': (191, 191, 191),
            'dark gray': (191, 191, 191),
            'light grey': (64, 64, 64),
            'light gray': (64, 64, 64)
        }
    
        # List of valid color names
        valid_colors = list(color_map.keys())

        # If color_name is None or not valid, select a random color
        if color is None or color.lower() not in color_map:
            random_pixels = np.random.randint(0, 256, (height, width, 3), dtype=np.uint8)
            img = Image.fromarray(random_pixels, 'RGB')

        else:        
            # Create an 8x8 image with the specified or randomly selected color
            img = Image.new('RGB', (8, 8), color_map[color.lower()])

        # Save
        if not filepath:
            img.save("test_image.jpg", "JPEG")
        else:
            img.save(filepath, "JPEG")
    
        return img

    @staticmethod
    def run(filepath, height=None, width=None, outpath=None, show=False):

        # Get the filename from the filepath
        #filename = filepath.split("\\")[-1].split(".")[0]
        #extension = filepath.split("\\")[-1].split(".")[-1]
        f = os.path.basename(filepath)
        filename, extension = os.path.splitext(f)
        if not outpath:
            outpath = os.path.dirname(filepath)

        # Process the image
        gbtd = GBTD(filepath)
        if show:
            gbtd.show_img()
        gbtd.convert_to_grayscale()
        if show:
            gbtd.show_img()
        gbtd.resize_image(height=height, width=width)
        if show:
            gbtd.show_img()
        gbtd.pad_img()
        gbtd.quantize_img()
        if show:
            gbtd.show_img()
        sections = gbtd.split_img()
        sections_pixels = [GBTD(sect).get_pixel_values() for sect in sections]
        gbtd_array = gbtd.convert_to_gbtd(sections_pixels)
        c_file, h_file = gbtd.write_c_h_files(gbtd_array, directory=outpath, filename=filename)

# Example usage
if __name__ == "__main__":

    #GBTD.generate_image(height=8,width=8,color="dark grey")
    #time.sleep(2)    
    #print("Generated test image")
    #GBTD.resize_image("test_image.jpg")
    #images = ["pacman.jpg"]
    images = sys.argv[1:]
    sz = None
    h = None
    w = None
    for i in images:
        if "size=" in i.lower():
            sz = i.lower().split("size=")[1]
            w = int(sz.split("x")[0])
            h = int(sz.split("x")[1])
            sz = None
            if w == 0:
                w = None
            if h == 0:
                h = None
        else:
            GBTD.run(i,height=h,width=w,show=True)

    # Create a random color image and show it
    #random_color_img = GBTD.generate_random_image()
    #random_color_img.show()

    # Convert the random color image to grayscale and process it
    #gbtd = GBTD('airport.jpg')
    #gbtd.convert_to_grayscale()
    #gbtd.pad_img()
    #gbtd.show_img()
    #gbtd.quantize_img()
    #gbtd.save_img('airport_out.jpg')
    #sections = gbtd.split_img()
    #sections_pixels = [GBTD(sect).get_pixel_values() for sect in sections]
    #gbtd_array = gbtd.convert_to_gbtd(sections_pixels)
    #print(gbtd_array)
    #c_file, h_file = gbtd.write_c_h_files(gbtd_array, filename="airport")
    #print(f"Generated files: {c_file}, {h_file}")
